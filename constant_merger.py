from numpy import loadtxt
import numpy as np
#import matplotlib.pyplot as plt

######################### DATAFILE NAME LISTS ###############################################
###Rockstar simulation catalog
Rockstar_hlist_address = "/store/multidark/ESMD_2048_Planck1/ROCKSTAR/hlists/"
Rockstar_catalog_address = "/store/multidark/ESMD_2048_Planck1/ROCKSTAR/catalogs/"
IDcol = 1
descIDcol = 3 #descendant ID, equals -1 for z = 0
masscol = 10
Rvircol = 11
xcol = 17
ycol = 18
zcol = 19
vxcol = 20
vycol = 21
vzcol = 22
bcol = 46
ccol = 47
subhalocol = 5

headerlength = 65 #number of lines for header

###candidates of LG mass
filename_high_res_filtered_lg_wsub = "high_res_massfiltered_lg.dat"
filename_high_res_filtered_lg_nosub = "high_res_massfiltered_lg_nosub.dat"
filename_high_res_filtered_lg_justsub = "high_res_massfiltered_lg_onlysub.dat"

###halos of OM mass
filename_high_res_filtered_overmassive = "high_res_massfiltered_overmassive.dat"

###binary indices via two algorithms: grid search and brute force N^2
#high_res_trueLG_index = "highresLG.dat"
filename_high_res_bf  = "LG_HR_bruteforce.dat" #LGB no subs

###filtered AHF entries of the population of true LG binaries
high_res_trueLG_pop = "high_res_trueLG_pop.dat" #result of distance searching algorithms
#hrtrueLG_nosubhalo_filtered = "high_res_trueLG_nosubhalo_filtered_pop.dat" #throw away halos that are subhalos
hrtrueLG_wosubhalo_biggap_filtered = "high_res_trueLG_nosubhalo_biggap_filtered_pop.dat" #throw away binaries with the largest, satellite > .5 minor. i.e. big gap between largest satellite and the minor partner

###subhalos
#filename_high_res_nosubLG_subhalos = "highres_subhalo.dat" #generated by subhaloFinder_indexed.py
#filename_high_res_biggapLG_subhalos = "highres_biggap_subhalo.dat"

### real pair properties
plotnameSvsH = "MsubvsMhost.pdf"
mSubvsHost_file = "MsubvsMhost.dat" #sub mass vs host mass
NumSatHist_file = "NumSatHist.dat" #number of satellite per host
princaxes_of_trueLGB_pairs = "princaxes_of_trueLGB_pairs.dat"
angles_bw_princaxes_of_trueLGB_pairs = "angles_bw_princaxes_of_trueLGB_pairs.dat" #cosine angle between A and B signal, determined by findprince.py finding principle axes from small satellite distribution

####smallhalos
#smallhalos_low_res = "low_res_massfiltered_smallhalos.dat" #produced from massfilter.py
#smallhalos_high_res = "high_res_massfiltered_smallhalos.dat"	

###cosine distribution data
#hrcosine_distn_file_z0 = "cosine_distn_file_a=1.0000.dat"
hrcosine_distn_file= "high_res_cosine_distn_file.dat"
hrcosine_distn_file_slice = "high_res_cosine_distn_file_roche_slice.dat"
#control sample

###isolated halo file
isolated_lg_file_nosub = "hr_isolated_lg_halo_nosub.dat" #produced from overlapping.py
Trueisolated_lg_file = "hr_isolated_true_lg.dat" #produced from overlapping.py
filename_hr_trueISO_pop = "hr_isolated_lg_pop.dat"
filename_hriso_subhalos = "hr_isolated_lg_sub.dat"

filename_hr_fakeBIN_pop = "hr_fake_LGB_pop.dat"

filename_matchedlist_control = "matchedlist_control.dat" #list of fakeA, fakeB, sepDis
filename_ControlRepeatedOccurence = "ControlRepeatedOccurence.dat" #list the fake halo host id (among the id'd isolated halo list) and the times it occurs in the control sample
filename_ControlRepeatedOccurence_pair = "ControlRepeatedOccurence_pair.dat" #list the fake halo binary and the times it occurs in the control sample

folder_smallhalo = "smallhalos_highres"
folder_smallhalo_merger = "smallhalos_highres_merg"
smallhaloIDfile = "smallhaloIDfile.dat"
hosthaloIDfile = "hosthaloIDfile.dat"

folder_control_not_rotated = "smallhalos_highres_iso_shifted_1.5dsep"
folder_control_rotated_to_sample = "smallhalos_highres_iso_shifted_1.5dsep_rotated_to_sample"#selecting for mass and eccentricity
#folder_control_rotated_to_sample_0 = "smallhalos_highres_iso_shifted_1.5dsep_rotated_to_sample_0" #only selecting mass in composing control binary
folder_control_rotated_to_self = "smallhalos_highres_iso_shifted_1.5dsep_rotated_to_self"#selecting for mass and eccentricity
folder_project = "smallhalos_highres_project_on_xy"

folder_plot_control = "LGbinary_highres_fake_1.5dsep"
folder_plot_control_rotated_to_sample = "LGbinary_highres_fake_1.5dsep_rotated_to_sample"

hrcosine_distn_file_fake = "high_res_cosine_distn_file_fake_1.5dsep.dat"
hrcosine_distn_file_fake_rotated = "high_res_cosine_distn_file_fake_1.5dsep_rotated.dat"
hrcosine_distn_file_fake_rotate_tosample = "high_res_cosine_distn_file_fake_1.5dsep_rotated_tosample.dat" #selecting for mass and eccentricity
#hrcosine_distn_file_fake_rotate_tosample_0 = "high_res_cosine_distn_file_fake_1.5dsep_rotated_tosample.dat"#only selecting mass in composing control binary
hrcosine_distn_file_fake_rotate_to_self = "high_res_cosine_distn_file_fake_1.5dsep_rotated_toself.dat"#selecting for mass and eccentricity
#####################################################################################################
#projection and rotation of sample
#####################################################################################################
##### projection of an identified halo and satellites on_axis = set that axis to 0, 
hrcosine_distn_file_project = "high_res_cosine_distn_file_project_on_y.dat"
# projection of a pair of host halo onto z plane and search for small halos around them, run smallhaloFinderNonindexed on 2D
hrcosine_distn_file_project_sat = "high_res_cosine_distn_file_project_on_xy_sat.dat"

#### rotating in the direction of the inertial tensor of the group: should get max signal, got uniform signal
hrcosine_distn_file_rotated = "high_res_cosine_distn_file_rotated.dat"

#######################################	collaboration #################################
# For elmo:
# List of IDs of binary halos (hosts)
list_for_elmo_host = "list_of_IDs_host.dat"
# list of IDS of small halos (satellites)
list_for_elmo_satellites = "list_of_IDs_satellites.dat"

################################## DISTANCE CONSTANTS ######################################

dim = 64e0

dimkpc = 64e3

LGdmin = 9e-2 #LGdmin sqrd = 9e-2, LGdmin = 3e-1
LGdmax = 2.25e0 #LGdmin sqrd = 2.25e0, LGdmin = 1.5
LGdmax_sqrt = 1.5e0

OLradiusratio = 1.5e0 #overlapping signal is created by the overlap of two halos. the degree of the overlapping of the two is measured by a radius Rs which applies to each host, and within Rs from host is the small halo counted as part of the overlap, once the two circles overlap, then the cosine angle is calculated but within the normal search range 1/2 D_sep. Rs can be 1.5D_sep or 1 D_sep, depending on the degree of overlap desired.

isosearchradius = LGdmax_sqrt * OLradiusratio #new search radius for isolated halo case = 1.5 dsep_max, which is 1.5 Mpc, within this radius, small haloes are saved to the isolated halo close to it under smallhalos_highres_iso titled folders, times 1.5 is because a given isolated halo might be used several times to compose a control sample halo, and the dsep is different in each case, so to be prepared for all overlapping distance and small halo search distance, we cut the largest box possible around each isolated halo
isosearchradius_sqd = isosearchradius ** 2e0

#XRadius = 9e0 #exclusion radius, a third body more massive than the junior partner should not be within this radius #used instead is b_sep to increase sample size

######################## DEFAULT VALUES FOR MASSES #########################################
LGmassmin_z0 = 1e11
LGmassmax_z0 = 5e12 #if this max is higher than e13 then need to make sure the sum of the viral radius of the two hosts should not be 						#greater than their distance
#OMmassmin = LGmassmax
#SMALLmassmax = LGmassmin

mass_function_dat_self = "mass_function_interpolated.dat" #self calculated mass function
massmincol_self = 3
massmaxcol_self = 4
#massmin_lis, massmax_lis = loadtxt(mass_function_dat_self, unpack =1, usecols = ())

mass_function_dat_noam = "Mstar.DAT-Planck-ESMD" #mass function sent by Noam
z_redshift, m_redshift = loadtxt(mass_function_dat_noam, unpack =1, usecols = (0,1), skiprows = 1)
#print(1/(1+z))
massmin_lis0 = m_redshift * (LGmassmin_z0/ m_redshift[0]) #scale according to z0 mass
massmax_lis0 = m_redshift * (LGmassmax_z0/ m_redshift[0]) #scale according to z0 mass
#plt.plot(z, massmin_lis0)
#plt.plot(z, massmax_lis0)
#plt.yscale('log')
#plt.show()
#print(massmin_lis0, massmax_lis0)
############################################################################################
# scatter plot dot size is equal to real mass normalized by this scale factor, larger this is smaller the dot
plotmassscale = 5e8
